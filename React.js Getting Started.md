# React.js: Getting Started

* Using JavaScript to render HTML allows React to have a virtual representation of HTML in-memory, which is known as the **virtual DOM**:
  * first React uses this concept to render an HTML tree virtually
  * then every time a `state` changes and we have a new HTML tree that needs to be written back to the browser's DOM, instead of writing the whole tree, React will only write the difference between the new tree and the previous tree, since React has both trees in-memory
  * this process is known as **tree reconciliation**, and I think it's the best thing that has happened in web development since AJAX

* `state` and `props` have one important difference; the `state` can be changed while the `props` are all fixed values

* React components are either **Function Component** or **Class Component**:
  * **Function Component**:
    * it is also referred to as stateless and is often associated with the presentational concept.
    * it is the simplest form of a React component. It receives an object of properties (`props`), and   returns JSX

  * **Class Component**:
    * it also acts like a function that receives props, but that function also considers a private internal `state` as additional input that controls the returned JSX.
    * this private internal `state` is what gives React its reactive nature. When the `state` of a class component changes, React will automatically re-render that component.
    * Class components can only change their internal `state`, not their properties.

This is a core idea to understand in React, and we're going to see examples of that. Let's look at an actual example of a component, a simple one, without any input and with just a simple h1 in a div output. On the left side, the component is written in the special JSX syntax. JSX allows us to describe our DOM in a syntax very close to the DOMs we're used to. It is, however, optional. React can be used without JSX, as you can see on the right side. In fact, React just compiles the JSX you see on the left to the pure JavaScript you see on the right, and then just works with the compiled JavaScript in the browser. What you see here is a JavaScript representation of the DOM, which React efficiently translates into DOM operations that it performs in the browser. Let's write a React component. I will be using jsComplete's REPL for this example. This REPL is a playground tool where we can test our JavaScript and React code right here in the browser; there is no need to install or configure anything. 
Go to jscomplete.com/repl, and you'll see this simple two-tab interface. The left tab is the editor; we write our JavaScript here. The latest version of React and ReactDOM are both already preloaded here, and this editor understands the JSX extension and all of the modern features in JavaScript so we'll get to focus on the React API itself, rather than wasting time configuring and compiling. The right tab is the preview tab. We have a predefined mountNode element, so when you execute your JavaScript code, anything you put in the mountNode element shows up in the preview tab. This tab will also show any error you encounter when you execute the code. This playground is also a simple JavaScript REPL where you can test quick JavaScript functions and expressions. To execute the code at any time, press Ctrl+Enter. To create a React component, simply define a new function. Let's make that function return an actual HTML button. What we returned here looks like HTML, but remember that it's not, it's going to be compiled into JavaScript. The actual JavaScript that the browser sees when we use this simple button element in JSX is this line, a call to the React.createElement function with a button argument and its child text node. You can actually use React this way without JSX, but that would make it a lot harder to code and maintain, so let's stick with JSX. This function here is a complete and very simple React component, let's use it. To use a component, we need to give it a name that we can reference, so let's put it in a constant and call it Button. Once we assign that reference, we don't want to change it, and that's why we use a constant statement here. The syntax to mount a component in the browser is ReactDOM.render, which takes in two arguments. The first is the component to render, which is just Button in our case, and the second argument is the element in which this component should be rendered. In this REPL's environment we can use the special mountNode variable. Note how I used a title case for the Button constant here. This is a requirement in React so that the library can distinguish between React elements like this one and regular HTML elements like this one. A React function component receives one argument, props. This argument allows us to make the component more reusable. For example, instead of hardcoding the label of the button, we can pass this component a label attribute, just like we do with regular HTML elements, then we can access this attribute inside the component with a curly bracket for props.label. So props is an object that holds all the values that were passed when the component was rendered. I like to use arrow functions where I can, so let me do that here. I don't need to pass any props yet to this component, so let me undo this to keep things simple for now. We have a button element, and it's rendered through a React component. Let's now add some interactivity to this so-far boring example. Let's make that button increment a counter on every click and display the value of that counter as the button label itself. So the label of this button is going to be a number, like 5, and when I click the button it will change to 6, 7, 8, and so on. Since this is something that needs to be changed in the component, it belongs to the state of the component. We basically need the component to re-render itself every time the counter changes. We can't use a property here because component properties are immutable. However, our button component is currently a function one and function components cannot have state, so we need to upgrade this component to a class component first. This is very simple. We first define a class that extends React.Component, and in that class we define a render function. This render function is what returns the component's JSX, the HTML button in our case. We don't need this previous function definition anymore. Now the button element is being rendered with a class component and we can start using a private state on that component. To use a state object we first need to initialize it. We do that inside the constructor of the Button class. We just define a constructor function, which receives a props object, and we'll call the super method here to honor the inheritance of this component. After that, we initialize this.state to whatever we want. The properties of this state object are the various elements of the state. For our case, we need a counter state, which should start from 0. Inside the render function, since we can write any JavaScript expression within curly brackets, we can read the value of the counter element that we just initialized on the state using this.state.counter. The this keyword refers to the component instance we're handing off to ReactDOM here. We can see here how the button got rendered with the value of 0. You can try and change that state to see how the button will render the value you put on the state. There is another shorter syntax to define this initial state, which is to simply to use a class property like this without a constructor call. This is not yet part of the official JavaScript language, but it looks like it's going to be. The syntax works in here because the jsComplete REPL playground uses Babel to transpile it to normal JavaScript that the browser will understand. Since this feature is likely to become part of JavaScript soon, I am going to use it throughout this course. When you configure your own React applications, you'll have to use something like Babel JS anyway to compile JSX into JavaScript, so it's a big easy win to also include and use the JavaScript features that are well on their way to become an official part of the language. We have a state object and we have a button that displays that state. Now we need to change that state when we click the button, so we need to define a click handler on that button. React comes with normalized events that are easy to use. For this case, we need the onClick event, which we define right here on the Button element. Unlike DOM event handlers which use a string, React event handlers use an actual JavaScript function. This function can be a global one like this or an inline function like this, but the standard practice is to define this function on the class component itself. I'll call it handleClick, and we can define it on the component as an instance property. We're again using the modern class property syntax here, which allows us to use arrow functions that are bound to the component instance. HandleClick will now act as a prototype function on this class, and inside handleClick the keyword, this, refers to the component instance that we're sending to the DOM. HandleClick's job is easy, read the current counter out of the state. We can do that using this.state.counter, and then increment this value, and then update the component state with the new incremented value. We can use React's built-in setState method, which is available on every class component instance, to update a component state. Our button will now increment its label on every click. Let's review. We defined an event handler for the click method, and every time you click this button the handleClick function will be executed. The function reads the current state of the counter value, increments it, and then sets the state to the new value of the counter. React takes care of all the rendering needed after these changes so you don't have to worry about that. Simple and powerful. There is one tiny improvement that we should make on this component before moving on. React's setState method is an asynchronous one, which just schedules an update, and multiple setState calls might potentially be batched for performance. Since we're both reading and writing to the state object in this example, theoretically we might hit a race condition. The general rule of thumb here is whenever you need to update the state using a value from the current state, use the other contract of the setState method, which is a function instead of an object. This argument function receives a prevState object that we can confidently use without worrying about race conditions. This function returns the object that we want to use to set the state. You only need to use this second syntax of setState if your update depends on the current state. Since we're just returning an object here, we can use the arrow function short syntax for that, but we'll need to wrap the object in parenthesis, like this.

